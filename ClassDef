"""
Quasar_Lens: Code for calculating and graphing quasar Lensing Optical Depth,
Magnification Bias and Probability of Lensing
Author: Matt Stanton, The University of Melbourne
Email: msstan@student.unimelb.edu.au

Version 1.0
23/02/2024
"""

############
#  Set-Up  #
############
import numpy as np
from astropy.cosmology import FlatLambdaCDM
from scipy.integrate import quad
from scipy.integrate import dblquad
import matplotlib.pyplot as plt
import sympy as sp
from time import time
import sys
#start_time = time()

######################
#  Class Definition  #
######################

class Quasar_Lens():
    def __init__(self, zs, Mlim, prob_dist='total', 
                 H0=70, OM0=0.3,  # Cosmology Parameters
                 sigma0='172.2 * (1+z)**0.18', phi0 = '6.917933918e-3 * (1+z)**-1.18',  # VDF parameters
                 a=-0.15, b=2.35,  # VDF parameters (cont)
                 alpha=-1.3, beta=-2.6, Ms=-25, Phis=10.9e-9,  # QLF parameters
                 mu_min=2, B_dash=1, alphaK=-0.5):
        """
        Get input data
         Parameters
        ----------
        zs : integer
            The redshift of the source.
        Mlim : integer
            Limiting magnitude of the flux survey.
        prob_dist : string, optional
            Either 'bright' (multiple images can be seperately resolved) 
            or 'total' (lensed images are blended). The default is 'total'.
        H0 : integer, optional
            Hubble constant. The default is 70.
        OM0 : integer, optional
            Omega matter density. The default is 0.3.
        sigma0 : string, optional
            Sigma star value to be used in the VDF, input any function of z as a string. 
            The default is '172.2 * (1+z)**0.18', from Yue et al. 2021 (as are all subsequent parameter values).
        phi0 : string, optional
            Phi star value to be used in the VDF, input any function of z as a string. 
            The default is '6.917933918e-3 * (1+z)**-1.18'.
        a : integer, optional
            a-value to be used in the VDF. The default is -0.15.
        b : integer, optional
            b-value to be used in the VDF. The default is 2.35.
        alpha : integer, optional
            Faint-end slope of the QLF. The default is -1.3.
        beta : integer, optional
            Bright-end slope of the QLF. The default is -2.6.
        Ms : integer, optional
            Break magnitude of the QLF. The default is -25.
        Phis : integer, optional
            Normalisation of the QLF, will not effect QLF or probability of lensing values. 
            The default is 10.9e-9.
        mu_min : integer, optional
            Minimum magnification. The default is 2.
        B_dash : integer, optional
            Magnification bias of sources that are not multiply imaged.
            The default is 1.
        alphaK : integer, optional
            Spectral index for the K-correction calculation. 
            Note the K-correction is determined using a power law relationship,
            to change this please manually alter the code. 
            The default is -0.5.
            
        Returns
        -------
        None.

        """
        
        if prob_dist == 'bright':
            self.prob_dist = 'bright'
        else:
            self.prob_dist = 'total'
        self.zs = zs
        self.Mlim = Mlim
        self.H0 = H0
        self.OM0 = OM0         
        self.z = sp.symbols('z')  # Allow functions of redshift as vdf parameter values
        self.phi0 = sp.lambdify(self.z, sp.sympify(phi0), 'numpy')
        self.sigma0 = sp.lambdify(self.z, sp.sympify(sigma0), 'numpy')
        self.a = a
        self.b = b
        self.alpha = alpha
        self.beta = beta
        self.Ms = Ms
        self.Phis = Phis
        self.mu_min = mu_min
        self.B_dash = B_dash
        self.cosmo = FlatLambdaCDM(H0, OM0)  # Define the cosmology
        
        # K-correction for magnitude conversion. Note that the power law convention
        # is used to compute the K-correction, so it may not be entirely accurate,
        # particularly at high z-shifts
        self.alphaK = alphaK
        self.K_correc = 2.5 * (self.alphaK + 1) * np.log(1 + self.zs)
        
        # Convert to absolute magnitude given apparent magnitude input
        if self.zs > 0:  # Avoid division by 0
            if self.Mlim > 0:
                self.mlim = self.Mlim  # Prevent K-correction graph from not running this condition after initialisation
                self.Mlim = (self.Mlim 
                             - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                             + 5 + self.K_correc)
        else:
            print("Please enter a valid redshift value (must be strictly greater than 0)")
            sys.exit()
        
    ##################################
    #  Lensing Optical Depth Method  #
    ##################################   
   
  
    def tau_integrand(self, sigma, z):
        # Define integrand that will be fed into integration function
        if z>self.zs:  # Avoid division by zero or bugged integration
            return 0
        if z<=0:
            print("Please enter a valid range of redshift values (must be strictly greater than 0)")
            return

        vdf = (self.phi0(z) * (sigma/self.sigma0(z))**self.a 
               * np.exp(-(sigma/self.sigma0(z))**self.b) * 1/(sigma))
        
        dV = self.cosmo.differential_comoving_volume(z).value
        
        theta_E = (4 * np.pi * (sigma/3e5)**2 
                   * self.cosmo.angular_diameter_distance_z1z2(z,self.zs) 
                   / self.cosmo.angular_diameter_distance(self.zs))
       
        tau_integral = vdf * dV * np.pi * theta_E**2
      
        return tau_integral
 
    def tau_m(self):
        """Compute the lensing optical depth for the given class inputs."""
        integral = dblquad(self.tau_integrand, 0, self.zs, 0, 1000)
        # Note that the upper sigma bound of 1000 is slightly excessive and performance 
        # could be improved by lowering this to ~750 with minimal effect in most cases
        return integral[0]
    
    ###############################
    #  Magnification Bias Method  #
    ###############################
   
    def prob_dist_func(self, mu):
        # Define the probability distribution of magnification of lensed sources
        if self.prob_dist == 'bright':
            return 2 / (mu - 1)**3
        if self.prob_dist == 'total':
            return 8 / mu**3
  
    def qlf(self, M):
        # Define the QLF, using the double power law defined as in Yue et al. (2021)
        qlf_integral = (self.Phis 
                        / (10**(0.4 * (self.alpha+1) * (M-self.Ms))
                        + (10**(0.4 * (self.beta+1) * (M-self.Ms)))))
        return qlf_integral
   
    def m_function(self, mu):
        # Define the function of mu to be used as the upper integration bound on the numerator   
        return self.Mlim + 2.5 * np.log10(mu)
     
    def qlf_int(self, mu, m):
        # Define the integration of the QLF, taking as argument the upper integration bound
        Phi_int = quad(self.qlf, -40, m(mu))
        return Phi_int[0]
    
    def numer_integrand(self, mu, m):
        # Multiply the above by the magnification probability distribution
        numer_integral = self.qlf_int(mu, m) * self.prob_dist_func(mu)
        return numer_integral
   
    def numer(self, m_func):
        # Integration for the numerator
        numer_int = quad(lambda mu: self.numer_integrand(mu, m_func),  # Lambda function so mu as argument and nested functions works
                         self.mu_min, np.infty)
        return numer_int[0]
  
 
    def numerator(self):
        # Execute the above methods involved in the numerator calculation
        return self.numer(self.m_function)
     
    def denominator(self):
        # Same but for the denominator
        denom_int = quad(self.qlf, -40, self.Mlim)
        return denom_int[0]
    
    def B(self):
        """Calculate magnification bias for the given class inputs."""
        return self.numerator()/self.denominator()
        
    ###################################
    #  Probability of Lensing Method  #   
    ###################################
        
    def prob_lens(self):
        """
        Calculate the probability of lensing for the given class inputs.
      
        Parameters
        ----------
        None.
     
        Returns
        -------
        prob_lens() : integer
            The probability that a source quasar is lensed given the class input parameters.
            
        Example
        -------
        >>> Quasar = Quasar_Lens(zs=6, Mlim=23, prob_dist='total')
        >>> Quasar.prob_lens()
        0.017277945745219656
        
        """
        t = self.tau_m()
        b = self.B()
        return (b*t) / (b*t + self.B_dash*(1-t))
     
    ####################################
    #  Graphing Lensing Optical Depth  #
    ####################################
     # Standard Scale
    def tau_m_graph(self, var_min, var_max, variable='zs', scale='standard', 
                    secondary_variable='none', secondary_variable_values=[]):
        """
        Graph the lensing optical depth against any one of the parameters in its calculation,
        using any other parameter as a secondary variable for which different graphs will be plotted.
        Parameters
        ----------
        var_min : integer
            The minimum value of the chosen variable which tau_m will be graphed against.
        var_max : TYPE
            The maximum value of the chosen variable which tau_m will be graphed against.
        variable : string, optional
            The primary variable against which tau_m will be graphed. 
            Choose from 'zs', 'H0', 'OM0', 'sigma0', 'phi0', 'a', or 'b'. 
            The default is 'zs'.
        scale : string, optional
            The scale used for the graph. 
            Choose from 'standard', 'log' (y-axis plotted using a log scale)
            or 'log vs log' (both axes plotted on a log scale where possible).
            The default is 'standard'.
        secondary_variable : string, optional
            The secondary variable for which different lines will be plotted.
            The default is 'none'.
        secondary_variable_values : list, optional
            The values of the secondary variable, each of which will have a 
            corresponding line plotted on the graph. 
            Note that sigma0 and phi0 can take functions of z as string inputs in this case.
            The default is [].
            E.g. secondary_variable_values=[65, 70, 75]

        Returns
        -------
        plot
            A graph of the lensing optical depth against the chosen primary variable
            with a line for each value of the secondary variable, on the chosen scale.
            
        Example
        -------
        >>> Quasar = Quasar_Lens(zs=6, Mlim=23, prob_dist='total')
        >>> Quasar.tau_m_graph(0.1, 6, 'zs', secondary_variable='H0', secondary_variable_values=[65,70,75])
        """
    
        # Create an array of values given the desired minimum and maximum values
        var_values = np.linspace(var_min, var_max, 100)
         
        # Create a dictionary assigning each variable input to its instance
        # value within the class, which will then be overwritten for chosen variables
        default_values = {'zs': self.zs,
                          'Mlim': self.mlim,
                          'prob_dist': self.prob_dist,
                          'H0': self.H0,
                          'OM0': self.OM0,
                          'sigma0': self.sigma0(self.z),
                          'phi0': self.phi0(self.z),
                          'a': self.a,
                          'b': self.b,
                          'alpha': self.alpha,
                          'beta': self.beta,
                          'Ms': self.Ms,
                          'Phis': self.Phis,
                          'mu_min': self.mu_min,
                          'B_dash': self.B_dash,
                          'alphaK': self.alphaK
                           }
         
        # Define the full variable names for labelling the axis
        if variable == 'zs':
            var_name = 'Redshift'
        elif variable == 'H0':
            var_name = 'Hubble Constant'
        elif variable == 'OM0':
            var_name = 'Omega Matter Density'
        elif variable == 'sigma0':
            var_name = 'Sigma Star'
        elif variable == 'phi0':
            var_name = 'Phi Star'
        elif variable == 'a':
            var_name = 'a-parameter'
        elif variable == 'b':
            var_name = 'b-parameter'  
        else:
            print("Please enter valid variable name")
            
        # Initialize list to store tau_m values
        tau_m_values = []
                
        # Create an array of arrays of tau_m values for each combination of primary and secondary variables
        if secondary_variable != 'none':
            if secondary_variable == 'mlim':
                secondary_variable = 'Mlim'
            for sec_var_value in secondary_variable_values:
                default_values[secondary_variable] = sec_var_value  # Overwriting the class inputs
                temp_list_1 = []
                for var_value in var_values:
                    default_values[variable] = var_value  # Overwriting the class inputs
                    kwargs = default_values.copy()  # Making a dictionary of keyword arguments
                    quasar_lens_instance = Quasar_Lens(**kwargs)  # Feeding kwargs into class to create respective definitions
                    tau_m_quasar_lens_instance = quasar_lens_instance.tau_m()
                    temp_list_1.append(tau_m_quasar_lens_instance)
                tau_m_values.append(temp_list_1)
        else:
            temp_list_1 = []
            for var_value in var_values[0]:
                default_values[variable] = var_value
                kwargs = default_values.copy()
                quasar_lens_instance = Quasar_Lens(**kwargs)
                tau_m_quasar_lens_instance = quasar_lens_instance.tau_m()
                temp_list_1.append(tau_m_quasar_lens_instance)
            tau_m_values.append(temp_list_1)
        
        # Plot the results
        if len(secondary_variable_values)==0:
            secondary_variable_values = ['empty']  # So code doesn't try to take the 0th index of an empty list
     
        temp2 = 0
        colours = ['#000F46', '#eb7bbe', '#46c8f0', '#ffd629',  # Unimelb style guide colours,
                   '#9fb825', '#78000d', '#ff2d3c', '#2c421d']  # change to suit own needs 
        for k in tau_m_values:
            if scale == 'standard':
                plt.plot(var_values, tau_m_values[temp2], 
                         label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                         color = colours[temp2], zorder = len(tau_m_values) - temp2)
                plt.xlabel('{} ({})'.format(var_name, variable))
                plt.ylabel('Lensing Optical Depth (tau_m)')
                plt.title('Lensing Optical Depth vs {}'.format(var_name))
                temp2+=1
            elif scale == 'log':
                plt.plot(var_values, np.log(tau_m_values[temp2]), 
                         label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                         color = colours[temp2], zorder = len(tau_m_values) - temp2)
                plt.xlabel('{} ({})'.format(var_name, variable))
                plt.ylabel('log(Lensing Optical Depth) (log(tau_m))')
                plt.title('Lensing Optical Depth vs {} on a log scale'.format(var_name))
                temp2+=1
            elif scale == 'log vs log':
                if any(val<=0 for val in var_values):  # Prevent negative values as input to log
                    print("log scale cannot be used when independent variable takes non-positive values")
                else:
                    plt.plot(np.log(var_values), np.log(tau_m_values[temp2]), 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(tau_m_values) - temp2)
                    plt.xlabel('log({}) (log({}))'.format(var_name, variable))
                    plt.ylabel('log(Lensing Optical Depth) (log(tau_m))')
                    plt.title('log(Lensing Optical Depth) vs log({})'.format(var_name))
                    temp2+=1
            else:
                print("Please enter a valid scale ('standard', 'log' or 'log vs log')")
                return
        if not(secondary_variable_values == ['empty']):
            plt.legend()  # Show legend only when secondary values are specified
        return plt.show()
  
     
  
    #####################################
    #  Graphing Magnification Bias (B)  #
    #####################################

    # Standard Scale
    def B_graph(self, var_min, var_max, variable='Mlim', scale='standard', 
                secondary_variable='none', secondary_variable_values=[]):
        """
        Graph the magnification bias against any one of the parameters in its calculation,
        using any other parameter as a secondary variable for which different graphs will be plotted.

        Parameters
        ----------
        var_min : integer
            The minimum value of the chosen variable which B will be graphed against.
        var_max : integer
            The maximum value of the chosen variable which B will be graphed against.
        variable : string, optional
            The primary variable against which B will be graphed. 
            Choose from 'Mlim'/'mlim', 'zs', 'alpha', 'beta', 'Ms', 'mu_min', or 'alphaK'. 
            The default is 'Mlim'.
        scale : string, optional
            The scale used for the graph. 
            Choose from 'standard', 'log' (y-axis plotted using a log scale)
            or 'log vs log' (both axes plotted on a log scale where possible).
            The default is 'standard'.
        secondary_variable : string, optional
            The secondary variable for which different lines will be plotted.
            Note that 'prob_dist' can be taken as input here in addition to the above list.
            The default is 'none'.
        secondary_variable_values : list, optional
            The values of the secondary variable, each of which will have a 
            corresponding line plotted on the graph.
            For prob_dist, values are 'bright' and 'total'.
            The default is [].
            E.g. secondary_variable_values=[-26, -25, -24]

        Returns
        -------
        plot
            A graph of the magnification bias against the chosen primary variable
            with a line for each value of the secondary variable, on the chosen scale.
        
        Example
        -------
        >>> Quasar = Quasar_Lens(zs=6, Mlim=23, prob_dist='total')
        >>> Quasar.B_graph(19, 23, variable='mlim', secondary_variable='Ms', 
                           secondary_variable_values=[-26, -25, -24])
        """
        
        # Create an array of values given the desired minimum and maximum values
        var_values = [np.linspace(var_min, var_max, 100)]
        app_variable = ''  
        app_secondary_variable = ''  # So these variables have length that can be queried later
        
        # Create a dictionary assigning each variable input to its instance
        # value within the class, which will then be overwritten for chosen variables
        default_values = {
        'zs': self.zs,
        'Mlim': self.mlim,  # So K-correction graph does not break due to conversion too early
        'prob_dist': self.prob_dist,
        'H0': self.H0,
        'OM0': self.OM0,
        'sigma0': self.sigma0(self.z),
        'phi0': self.phi0(self.z),
        'a': self.a,
        'b': self.b,
        'alpha': self.alpha,
        'beta': self.beta,
        'Ms': self.Ms,
        'Phis': self.Phis,
        'mu_min': self.mu_min,
        'B_dash': self.B_dash,
        'alphaK': self.alphaK
        }
        
        # Define the full variable names for labelling the axis
        if variable == 'Mlim' or variable == 'mlim':
            if var_max > 0:
                var_name = "Apparent Limiting Magnitude"
                app_variable = 'mlim'  # So can still be referenced on axis label
                variable = 'Mlim'  # Rename to avoid issues with keywords in class input
                app_var_values = var_values  # Save the inputted values to be used as x-axis
                if secondary_variable == 'alphaK':
                    var_values = []  # Clear variable values, will be updated later
                    for alphK in secondary_variable_values:
                        absolute_max = (var_max 
                                        - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                        + 5 + 2.5 * (alphK+1) * np.log(1+self.zs))
                        absolute_min = (var_min 
                                        - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                        + 5 + 2.5 * (alphK+1) * np.log(1+self.zs))
                        correc_array = np.linspace(absolute_min, absolute_max, 100)  # Array of updated values for the calculations from the K-corrections
                        var_values.append(correc_array)
                elif secondary_variable == 'zs': 
                    var_values = []  # Clear variable values, will be updated later
                    for z in secondary_variable_values:
                        absolute_max = (var_max 
                                        - 5 * np.log10(self.cosmo.luminosity_distance(z).value * 10**6) 
                                        + 5 + 2.5 * (self.alphaK+1) * np.log(1+z))
                        absolute_min = (var_min 
                                        - 5 * np.log10(self.cosmo.luminosity_distance(z).value * 10**6) 
                                        + 5 + 2.5 * (self.alphaK+1) * np.log(1+z))
                        z_array = np.linspace(absolute_min, absolute_max, 100) # Array of updated values for the calculations from the K-corrections
                        var_values.append(z_array)
                else:
                    absolute_max = (var_max 
                                    - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                    + 5 + self.K_correc)
                    absolute_min = (var_min 
                                    - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                    + 5 + self.K_correc)
                    var_values = [np.linspace(absolute_min, absolute_max, 100)]
            else:
                var_name = "Absolute Limiting Magnitude"
                variable = 'Mlim'        
        elif variable == 'zs':
            var_name = 'Redshift'           
        elif variable == 'alpha':
            var_name = 'Faint-End Slope'
        elif variable == 'beta':
            var_name = 'Bright-End Slope'
        elif variable == 'Ms':
            var_name = 'Break Magnitude'
        elif variable == 'mu_min':
            var_name = 'Minimum Magnification'
        elif variable == 'alphaK':
            var_name = 'Spectral Index'    
        else:
            print("Please enter valid variable name")            
    
        # Initialize lists to store B values
        B_values = []
        
        # Create an array of arrays of B values for each combination of primary and secondary variables
        if secondary_variable != 'none':
            if len(var_values) > 1:  # If variable is alphaK or zs
                temp1 = 0
                for sec_var_value in secondary_variable_values:
                    default_values[secondary_variable] = sec_var_value  # Overwriting the class inputs for secondary variables
                    temp_list_1 = []
                    for var_value in var_values[temp1]:
                        default_values[variable] = var_value  # Overwriting the class inputs for primary variables
                        kwargs = default_values.copy()  # Making a dictionary of keyword arguments
                        quasar_lens_instance = Quasar_Lens(**kwargs)  # Feeding kwargs into class to create respective definitions
                        B_quasar_lens_instance = quasar_lens_instance.B()
                        temp_list_1.append(B_quasar_lens_instance) 
                    B_values.append(temp_list_1)
                    temp1+=1
            elif secondary_variable == 'mlim':  # Same as above but for only one sublist of var_values
                app_secondary_variable = 'mlim'  # Have to change name so illegal keyword not inputted
                secondary_variable = 'Mlim'
                for sec_var_value in secondary_variable_values:
                    default_values[secondary_variable] = sec_var_value
                    temp_list_1 = []
                    for var_value in var_values[0]:
                        default_values[variable] = var_value
                        kwargs = default_values.copy()
                        quasar_lens_instance = Quasar_Lens(**kwargs)
                        B_quasar_lens_instance = quasar_lens_instance.B()
                        temp_list_1.append(B_quasar_lens_instance) 
                    B_values.append(temp_list_1)
            else:
                for sec_var_value in secondary_variable_values:  # Same as above but without special considerations
                    default_values[secondary_variable] = sec_var_value
                    temp_list_1 = []
                    for var_value in var_values[0]:
                        default_values[variable] = var_value
                        kwargs = default_values.copy()
                        quasar_lens_instance = Quasar_Lens(**kwargs)
                        B_quasar_lens_instance = quasar_lens_instance.B()
                        temp_list_1.append(B_quasar_lens_instance) 
                    B_values.append(temp_list_1)
                    
        else:  # Same as above but for no secondary variables
            temp_list_1 = []
            for var_value in var_values[0]:
                default_values[variable] = var_value
                kwargs = default_values.copy()
                quasar_lens_instance = Quasar_Lens(**kwargs)
                B_quasar_lens_instance = quasar_lens_instance.B()
                temp_list_1.append(B_quasar_lens_instance)
            B_values.append(temp_list_1)

        # Plot the results
        if len(secondary_variable_values)==0:  
            secondary_variable_values = ['empty']  # So code doesn't try to take the 0th index of an empty list
        temp2 = 0 
        colours = ['#000F46', '#eb7bbe', '#46c8f0', '#ffd629',  # Unimelb style guide colours,
                   '#9fb825', '#78000d', '#ff2d3c', '#2c421d']  # change to suit own needs
        for k in B_values:
            if scale == 'standard':
                if app_variable == 'mlim':
                    plt.plot(app_var_values[0], B_values[temp2], 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(B_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, app_variable))
                    plt.ylabel('Magnification Bias (B)')
                    plt.title('Magnification Bias vs {}'.format(var_name))
                else:
                    if app_secondary_variable == 'mlim':
                        plt.plot(var_values[0], B_values[temp2], 
                                 label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(B_values) - temp2)
                    else:
                        plt.plot(var_values[0], B_values[temp2], 
                                 label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(B_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, variable))
                    plt.ylabel('Magnification Bias (B)')
                    plt.title('Magnification Bias vs {}'.format(var_name))
                    
            elif scale == 'log':
                if app_variable == 'mlim':  # So x-axis uses inputted, not calculated, values
                    plt.plot(np.log(app_var_values[0]), B_values[temp2], 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(B_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, app_variable))
                    plt.ylabel('log(Magnification Bias) (log(B))')
                    plt.title('Magnification Bias vs {} on a log scale'.format(var_name))
                else:
                    if app_secondary_variable == 'mlim':
                        plt.plot(np.log(var_values[0]), B_values[temp2], 
                                 label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(B_values) - temp2)
                    else:
                        plt.plot(np.log(var_values[0]), B_values[temp2], 
                                 label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(B_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, variable))
                    plt.ylabel('log(Magnification Bias) (log(B))')
                    plt.title('Magnification Bias vs {} on a log scale'.format(var_name))

            elif scale == 'log vs log':
                if app_variable == 'mlim':
                    plt.plot(np.log(app_var_values[0]), np.log(B_values[temp2]), 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(B_values) - temp2)
                    plt.xlabel('log({}) (log({}))'.format(var_name, app_variable))
                    plt.ylabel('log(Magnification Bias) (log(B))')
                    plt.title('log(Magnification Bias) vs log({})'.format(var_name))
                else:
                    if any(val<=0 for val in var_values[0]):  # Prevent negative values as input to log
                        print("log scale cannot be used when independent variable takes non-positive values")
                        return
                    else:    
                        if app_secondary_variable == 'mlim':
                            plt.plot(np.log(var_values[0]), np.log(B_values[temp2]), 
                                     label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                     color = colours[temp2], zorder = len(B_values) - temp2)
                        else:
                            plt.plot(np.log(var_values[0]), np.log(B_values[temp2]), 
                                     label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                     color = colours[temp2], zorder = len(B_values) - temp2)
                        plt.xlabel('log({}) (log({}))'.format(var_name, variable))
                        plt.ylabel('log(Magnification Bias) (log(B))')
                        plt.title('log(Magnification Bias) vs log({})'.format(var_name))
            else:
                print("Please enter a valid scale ('standard', 'log' or 'log vs log')")
                return
            temp2+=1
        if not(secondary_variable_values == ['empty']):
            plt.legend()  # Show legend only when secondary values are specified
        return plt.show()


    #####################################
    #  Graphing Probability of Lensing  #
    #####################################

    # Standard Scale
    def prob_lens_graph(self, var_min, var_max, variable='zs', scale='standard', 
                        secondary_variable='none', secondary_variable_values=[]):
        """
        Graph the probability of lensing against any one of the parameters in its calculation,
        using any other parameter as a secondary variable for which different graphs will be plotted.

        var_min : integer
            The minimum value of the chosen variable which prob_lens will be graphed against.
        var_max : integer
            The maximum value of the chosen variable which prob_lens will be graphed against.
        variable : string, optional
            The primary variable against which prob_lens will be graphed. 
            Choose from 'zs', 'Mlim'/'mlim', 'H0', 'OM0', 'sigma0', 'phi0', 
            'a', or 'b', 'alpha', 'beta', 'Ms', 'mu_min', or 'alphaK'. 
            The default is 'zs'.
        scale : string, optional
            The scale used for the graph. 
            Choose from 'standard', 'log' (y-axis plotted using a log scale)
            or 'log vs log' (both axes plotted on a log scale where possible).
            The default is 'standard'.
        secondary_variable : string, optional
            The secondary variable for which different lines will be plotted.
            Note that 'prob_dist' can be taken as input here in addition to the above list.
            The default is 'none'.
        secondary_variable_values : list, optional
            The values of the secondary variable, each of which will have a 
            corresponding line plotted on the graph.
            Note that sigma0 and phi0 can take functions of z as string inputs in this case.
            For prob_dist, values are 'bright' and 'total'.
            The default is [].
            E.g. secondary_variable_values=[16.5, 17.5, 18.5]

        Returns
        -------
        plot
            A graph of the probability of lensing against the chosen primary variable
            with a line for each value of the secondary variable, on the chosen scale.
        
        Example
        -------
        >>> Quasar = Quasar_Lens(zs=6, Mlim=23, prob_dist='total')
        >>> Quasar.prob_lens_graph(0.1, 6, variable='zs', secondary_variable='mlim', 
                                   secondary_variable_values=[16.5, 17.5, 18.5])

        """
        
        # Create an array of values given the desired minimum and maximum values
        var_values = [np.linspace(var_min, var_max, 100)]
        app_variable = ''
        app_secondary_variable = ''  # So these variables have length that can be queried later
        
        # Create a dictionary assigning each variable input to its instance
        # value within the class, which will then be overwritten for chosen variables
        default_values = {
       'zs': self.zs,
       'Mlim': self.mlim,  # So K-correction graph does not break due to conversion too early
       'prob_dist': self.prob_dist,
       'H0': self.H0,
       'OM0': self.OM0,
       'sigma0': self.sigma0(self.z),
       'phi0': self.phi0(self.z),
       'a': self.a,
       'b': self.b,
       'alpha': self.alpha,
       'beta': self.beta,
       'Ms': self.Ms,
       'Phis': self.Phis,
       'mu_min': self.mu_min,
       'B_dash': self.B_dash,
       'alphaK': self.alphaK
       }
        
        # Define the full variable names for labelling the axis
        if variable == 'Mlim' or variable == 'mlim':
            if var_max > 0:
                var_name = "Apparent Limiting Magnitude"
                app_variable = 'mlim'  # So can still be referenced on axis label
                variable = 'Mlim'  # Rename to avoid issues with keywords in class input
                app_var_values = var_values  # Save the inputted values to be used as x-axis
                if secondary_variable == 'alphaK':
                    var_values = []  # Clear variable values, will be updated later
                    for alphK in secondary_variable_values:
                        absolute_max = (var_max 
                                       - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                       + 5 + 2.5 * (alphK + 1) * np.log(1 + self.zs))
                        absolute_min = (var_min 
                                       - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                       + 5 + 2.5 * (alphK + 1) * np.log(1 + self.zs))
                        correc_array = np.linspace(absolute_min, absolute_max, 100)
                        var_values.append(correc_array)  # Array of updated values for the calculations from the K-corrections
                elif secondary_variable == 'zs': 
                    var_values = []  # Clear variable values, will be updated later
                    for z in secondary_variable_values:
                        absolute_max = (var_max 
                                        - 5 * np.log10(self.cosmo.luminosity_distance(z).value * 10**6) 
                                        + 5 + 2.5 * (self.alphaK + 1) * np.log(1 + z))
                        absolute_min = (var_min 
                                        - 5 * np.log10(self.cosmo.luminosity_distance(z).value * 10**6) 
                                        + 5 + 2.5 * (self.alphaK + 1) * np.log(1 + z))
                        z_array = np.linspace(absolute_min, absolute_max, 100)
                        var_values.append(z_array)  # Array of updated values for the calculations from the K-corrections
                else:
                    absolute_max = (var_max 
                                    - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                    + 5 + self.K_correc)
                    absolute_min = (var_min 
                                    - 5 * np.log10(self.cosmo.luminosity_distance(self.zs).value * 10**6) 
                                    + 5 + self.K_correc)
                    var_values = [np.linspace(absolute_min, absolute_max, 100)]
            else:
                var_name = "Absolute Limiting Magnitude"
                variable = 'Mlim' 
        elif variable == 'zs':
            var_name = 'Redshift'
        elif variable == 'H0':
            var_name = 'Hubble Constant'
        elif variable == 'OM0':
            var_name = 'Omega Matter Density'
        elif variable == 'sigma0':
            var_name = 'Sigma Star'
        elif variable == 'phi0':
            var_name = 'Phi Star'            
        elif variable == 'a':
            var_name = 'a-parameter'
        elif variable == 'b':
            var_name = 'b-parameter'
        elif variable == 'alpha':
            var_name = 'Faint-End Slope'
        elif variable == 'beta':
            var_name = 'Bright-End Slope'
        elif variable == 'Ms':
            var_name = 'Break Magnitude'
        elif variable == 'mu_min':
            var_name = 'Minimum Magnification'
        elif variable == 'B_dash':
            var_name = 'Magnification Bias Not Multiply Imaged'
        elif variable == 'alphaK':
            var_name = 'Spectral Index'
            
        else:
            print("Please enter valid variable name")
            return  

        # Initialize lists to store quasar lens initialisations
        prob_lens_values = []
    
        # Create an array of arrays of prob_lens values for each combination of primary and secondary variables
        if secondary_variable != 'none':
            if len(var_values) > 1:  # If variable is alphaK or zs
                temp1 = 0
                for sec_var_value in secondary_variable_values:
                    default_values[secondary_variable] = sec_var_value  # Overwriting the class inputs for secondary variables
                    temp_list_1 = []
                    for var_value in var_values[temp1]:
                        default_values[variable] = var_value  # Overwriting the class inputs for primary variables
                        kwargs = default_values.copy()  # Making a dictionary of keyword arguments
                        quasar_lens_instance = Quasar_Lens(**kwargs)  # Feeding kwargs into class to create respective definitions
                        prob_lens_quasar_lens_instance = quasar_lens_instance.prob_lens()
                        temp_list_1.append(prob_lens_quasar_lens_instance) 
                    prob_lens_values.append(temp_list_1)
                    temp1+=1
            elif secondary_variable == 'mlim':  # Same as above but for only one sublist of var_values
                app_secondary_variable = 'mlim'  # Have to change name so illegal keyword not inputted
                secondary_variable = 'Mlim'
                for sec_var_value in secondary_variable_values:
                    default_values[secondary_variable] = sec_var_value
                    temp_list_1 = []
                    for var_value in var_values[0]:
                        default_values[variable] = var_value
                        kwargs = default_values.copy()
                        quasar_lens_instance = Quasar_Lens(**kwargs)
                        prob_lens_quasar_lens_instance = quasar_lens_instance.prob_lens()
                        temp_list_1.append(prob_lens_quasar_lens_instance) 
                    prob_lens_values.append(temp_list_1)
            else:
                for sec_var_value in secondary_variable_values:  # Same as above but without any special considerations
                    default_values[secondary_variable] = sec_var_value
                    temp_list_1 = []
                    for var_value in var_values[0]:
                        default_values[variable] = var_value
                        kwargs = default_values.copy()
                        quasar_lens_instance = Quasar_Lens(**kwargs)
                        prob_lens_quasar_lens_instance = quasar_lens_instance.prob_lens()
                        temp_list_1.append(prob_lens_quasar_lens_instance) 
                    prob_lens_values.append(temp_list_1)
                    
        else:  # Same as above but for no secondary variables
            temp_list_1 = []
            for var_value in var_values[0]:
                default_values[variable] = var_value
                kwargs = default_values.copy()
                quasar_lens_instance = Quasar_Lens(**kwargs)
                prob_lens_quasar_lens_instance = quasar_lens_instance.prob_lens()
                temp_list_1.append(prob_lens_quasar_lens_instance)
            prob_lens_values.append(temp_list_1)
         
        # Plot the results
        if len(secondary_variable_values)==0:
            secondary_variable_values = ['empty']  # So code doesn't try to take the 0th index of an empty list
      
        temp2 = 0
        colours = ['#000F46', '#eb7bbe', '#46c8f0', '#ffd629',  # Unimelb style guide colours,
                   '#9fb825', '#78000d', '#ff2d3c', '#2c421d']  # change to suit own needs
        for k in prob_lens_values:
            if scale == 'standard':
                if app_variable == 'mlim':  # So x-axis uses inputted, not calculated, values
                    plt.plot(app_var_values[0], prob_lens_values[temp2], 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, app_variable))
                    plt.ylabel('Probability of Lensing (prob_lens)')
                    plt.title('Probability of Lensing vs {}'.format(var_name))
                else:
                    if app_secondary_variable == 'mlim':
                        plt.plot(var_values[0], prob_lens_values[temp2], 
                                 label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    else:
                        plt.plot(var_values[0], prob_lens_values[temp2], 
                                 label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, variable))
                    plt.ylabel('Probability of Lensing (prob_lens)')
                    plt.title('Probability of Lensing vs {}'.format(var_name))
                 
            elif scale == 'log':
                if app_variable == 'mlim':
                    plt.plot(np.log(app_var_values[0]), prob_lens_values[temp2], 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, app_variable))
                    plt.ylabel('log(Probability of Lensing) (log(prob_lens))')
                    plt.title('Probability of Lensing vs {} on a log scale'.format(var_name))
                else:
                    if app_secondary_variable == 'mlim':
                        plt.plot(np.log(var_values[0]), prob_lens_values[temp2], 
                                 label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    else:
                        plt.plot(np.log(var_values[0]), prob_lens_values[temp2], 
                                 label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                                 color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    plt.xlabel('{} ({})'.format(var_name, variable))
                    plt.ylabel('log(Probability of Lensing) (log(prob_lens))')
                    plt.title('Probability of Lensing vs {} on a log scale'.format(var_name))

            elif scale == 'log vs log':
                if app_variable == 'mlim':
                    plt.plot(np.log(app_var_values[0]), np.log(prob_lens_values[temp2]), 
                             label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                             color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                    plt.xlabel('log({}) (log({}))'.format(var_name, app_variable))
                    plt.ylabel('log(Probability of Lensing) (log(prob_lens))')
                    plt.title('log(Probability of Lensing) vs log({})'.format(var_name))
                else:
                    if any(val<=0 for val in var_values[0]):  # Prevent negative values as input to log
                        print("log scale cannot be used when independent variable takes non-positive values")
                        return
                    else:    
                        if app_secondary_variable == 'mlim':
                            plt.plot(np.log(var_values[0]), np.log(prob_lens_values[temp2]), 
                                     label='{} = {}'.format(app_secondary_variable,secondary_variable_values[temp2]), 
                                     color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                        else:
                            plt.plot(np.log(var_values[0]), np.log(prob_lens_values[temp2]), 
                                     label='{} = {}'.format(secondary_variable,secondary_variable_values[temp2]), 
                                     color = colours[temp2], zorder = len(prob_lens_values) - temp2)
                        plt.xlabel('log({}) (log({}))'.format(var_name, variable))
                        plt.ylabel('log(Probability of Lensing) (log(prob_lens))')
                        plt.title('log(Probability of Lensing) vs log({})'.format(var_name))
            else:
                print("Please enter a valid scale ('standard', 'log' or 'log vs log')")
                return
            temp2+=1
        if not(secondary_variable_values == ['empty']):
            plt.legend()  # Show legend only when secondary values are specified
        return plt.show()

###############
#  Workspace  #
###############
# Define the quasar class to be worked in, change attribute values as required
Quasar = Quasar_Lens(zs=3.962, Mlim=16.5, prob_dist='total')
# Calculations of numerical values
print('The lensing optical depth is', Quasar.tau_m())
print('The magnification bias is', Quasar.B())
print('The probability of lensing is', Quasar.prob_lens())
# Graphs, comment/uncomment based on desired dependent variable and change inputs as required
#Quasar.tau_m_graph(0.1, 6, 'zs')
#Quasar.B_graph(16, 23, 'mlim')
Quasar.prob_lens_graph(0.1, 6, 'zs', secondary_variable='mlim', secondary_variable_values=[16.5, 17.5, 18.5])

############
#  Timing  #
############

# Uncomment, along with start_time on line 22, to get time for code to run if desired (graphs will take a while)
#end_time = time()
#total_time = end_time-start_time
#print('Time taken =', total_time)




















